<!--
 * @Author: your name
 * @Date: 2021-05-19 16:41:59
 * @LastEditTime: 2021-05-20 16:25:08
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /my-docs/docs/684647234.md
-->

## 什么是Tree-shaking
<img src='./_media/160bfdcf2a31ce4a.gif' width='50%' />

上图形象的解释了 `tree-shaking` 的本意。

>`Tree-shaking` 较早由 `Rich_Harris` 的 `rollup` 实现，后来，`webpack2` 也增加了 `tree-shaking` 的功能。其实在更早，`google` `closure compiler` 也做过类似的事情。本文都以 `webpack` 为例。

<div class="Alert Alert--point">

前端中的 `tree-shaking` 可以理解为通过工具 "**摇**" 我们的 `JS` 文件，将其中用不到的代码 "**摇**" 掉，是一个性能优化的范畴。

</div>

具体来说，在 `webpack` 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。

实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 `tree-shaking`，将没有使用的模块摇掉，这样来达到 **删除无用代码** 的目的。

## Tree-shaking的原理

>`Tree-shaking` 的本质是消除无用的 `js` 代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为 `DCE`（`dead code elimination`）

`Tree-shaking` 是 `DCE` 的一种新的实现，`JS` 同传统的编程语言不同的是，`jS` 绝大多数情况需要通过网络进行加载，然后执行，加载的文件大小越小，整体执行时间更短，所以去除无用代码以减少文件体积，对 `jS` 来说更有意义。

<div class="Alert Alert--point">

`Tree-shaking` 和传统的 `DCE` 的方法又不太一样，传统的 `DCE` 消灭不可能执行的代码，而 `Tree-shaking` 更关注于消除没有用到的代码。

</div>

### JS中的DCE

传统编译型的语言中，都是由编译器将 `Dead Code` 从 `AST`（抽象语法树）中删除，那 `JS` 中是由谁做 `DCE` 呢？

首先肯定不是浏览器做 `DCE`，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。

可以由著名的代码压缩优化工具 `uglify` 来完成 `JS` 的 `DCE`。

### Webpack中的Tree-shaking

前面提到了 `tree-shaking` 更关注于无用模块的消除，消除那些 **引用了** 但并 **没有被使用** 的模块。

为什么 `tree-shaking` 是最近几年流行起来了？

前端模块化概念已经有很多年历史了，其实 `tree-shaking` 的消除原理是依赖于 `ES6` 的 **模块特性**。

回顾一下 `ES6 module` 特点：

- 只能作为模块顶层的语句出现

- `import` 的模块名只能是字符串常量

- `import binding` 是 `immutable` 的

<div class="Alert Alert--point">

`ES6` 模块 **依赖关系** 是确定的，和 **运行时的状态无关**，可以进行 **可靠的静态分析**，这就是 `tree-shaking` 的基础。

所谓静态分析就是 **不执行代码**，从字面量上对代码进行分析，`ES6` 之前的模块化，比如我们可以**动态 `require`** 一个模块，只有执行后才知道引用的什么模块，这个就 **不能通过静态分析** 去做优化。

这是 `ES6 modules` 在设计时的一个重要考量，也是为什么没有直接采用 `CommonJS`，正是基于这个基础上，才使得 `tree-shaking` 成为可能，这也是为什么 `rollup` 和 `webpack2` 都要用 `ES6 module syntax` 才能 `tree-shaking`。

</div>


