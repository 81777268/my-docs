<!--
 * @Author: your name
 * @Date: 2021-05-20 16:27:27
 * @LastEditTime: 2021-05-20 17:41:58
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /my-docs/docs/7203470234.md
-->

## 不同端的使用限制

|         | require/exports | import/export                                                             |
| ------- | --------------- | ------------------------------------------------------------------------- |
| Node.js | 所有版本        | Node 9.0+（启动需加上 flag --experimental-modules）Node 13.2+（直接启动） |
| Chrome  | 不支持          | 61+                                                                       |
| Firefox | 不支持          | 60+                                                                       |
| Safari  | 不支持          | 10.1+                                                                     |
| Edge    | 不支持          | 16+                                                                       |

`CommonJS` 模块化方案 `require/exports` 是为服务器端开发设计的。

服务器模块系统 **同步读取模块文件** 内容，编译执行后得到模块接口。（`Node.js`是 `CommonJS` 规范的实现）。

在浏览器端，因为其 **异步加载脚本文件** 的特性，`CommonJS` 规范无法正常加载。所以出现了 `RequireJS`、`SeaJS` 等（兼容 `CommonJS` ）为浏览器设计的模块化方案。

两种方案各有各的限制，需要注意以下几点：

- 原生浏览器不支持 `require/exports`，可使用支持 `CommonJS` 模块规范的 `Browsersify`、`webpack` 等打包工具，它们会将 `require/exports` 转换成能在浏览器使用的代码。

- `import/export` 在浏览器中无法直接使用，我们需要在引入模块的 `<script> 元素上添加type="module属性"`。

- 即使 `Node.js 13.2+` 已经支持 `import/export`，`Node.js` 官方不建议在正式环境使用，目前可以使用 `babel` 将 `ES6` 的模块系统编译成 `CommonJS` 规范（注意：语法一样，但具体实现还 是 `require/exports`）。

## 运行时机

> `CommonJS` 加载的是一个对象（即 `module.exports` 属性），该对象只有在 **脚本运行完** 才会生成。而 `ES6` 模块不是对象，它的对外接口只是一种 **静态定义**，在代码 **静态解析** 阶段就会生成。

`import` 命令是编译阶段执行的，在代码运行之前，因此意味着被导入的模块会先运行，而导入模块的文件会后执行。`require` 在运行代码时加载依赖项。

## 导出值

`require/exports` 输出的是 **值的拷贝**。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

`import/export` 模块输出的是 **值的引用**。`JS` 引擎对脚本静态分析的时候，遇到模块加载命令 `import`，就会生成一个 **只读引用**。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

若文件引用的 **模块值改变**，`require` 引入的模块值不会改变，而 `import` 引入的模块值会改变。

## 用法不一致

### require/exports 的用法

```js
const fs = require("fs");
exports.fs = fs;
module.exports = fs;
```

`exports` 是对 `module.exports` 的引用，相当于

```js
exports = module.exports = {};
```

在不改变 `exports` 指向的情况下，使用 `exports` 和 `module.exports` 没有区别；

如果将 `exports` 指向了其他对象，`exports` 改变不会改变模块输出值。示例如下：

```js
//utils.js
let a = 100;

exports.a = 200;
console.log(module.exports); //{a : 200}
exports = { a: 300 }; //exports 指向其他内存区

//test.js
var a = require("./utils");
console.log(a); // 打印为 {a : 200}
```

### import/export 的用法

```js
import fs from 'fs'
import { readFile } from 'fs' //从 fs 导入 readFile 模块
import { default as fs } from 'fs' //从 fs 中导入使用 export default 导出的模块
import * as fileSystem from 'fs' //从 fs 导入所有模块，引用对象名为 fileSystem
import { readFile as read } from 'fs' //从 fs 导入 readFile 模块，引用对象名为 read

export default fs
export const fs
export function readFile
export { readFile, read }
export * from 'fs'
```

> 建议明确列出我们要引用的内容。使用 \* 虽然很方便，但是不利于现代的构建工具检测未被使用的函数，影响代码优化。

<div class="Alert">

1. 引入 `export default` 导出的模块不用加 {},引入 export 导出的模块需要加 {}。

2. 一个文件只能导出一个 default 模块。

</div>

## 引用顺序

`ES6` 模块可以在 `import` 引用语句前使用模块，`CommonJS` 则需要先引用后使用。

```js
// ES6 模块

//test.js
export const test = "test";

//index.js
console.log(test); //test
import { test } from "./test.js";
console.log(test); //test
```

```js
//CommonJS

//test.js
exports.test = 'test';

//index.js
console.log(test)  // ReferenceError: test is not defined
test = require('./test');
console.log(atest
```

## 引用位置

`import/export` 只能在模块顶层使用，不能在函数、判断语句等代码块之中引用；`require/exports` 可以;

```js
function a() {
  import test from "./test.js";
  console.log(test);
}
a(); //Uncaught SyntaxError: Unexpected token '{'
```

> `import/export` 在 **代码静态解析阶段** 就会生成，不会去分析代码块里面的 `import/export`，所以程序报语法错误，而不是运行时错误。

## 是否采用严格模式

> 严格模式是采用具有限制性 `JS` 变体的一种方式

`import/export` 导出的模块 **默认调用严格模式**。

```js
let test = () => {
  bar = 17; //bar is not defined
};
export default test;
```

`require/exports` **默认不使用严格模式**，可以自定义是否使用严格模式。

```js
exports.test = () => {
  bar = 17; 
};
```
