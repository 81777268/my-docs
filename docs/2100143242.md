<!--
 * @Author: your name
 * @Date: 2021-11-25 14:22:25
 * @LastEditTime: 2021-11-25 15:03:08
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /my-docs/docs/2100143242.md
-->

## 移动端开发种类

- 原生开发

- **`Hybrid`** **`H5` + 原生**（`Cordova`、`Ionic`、微信小程序）

- **`JavaScript` 开发** + **原生渲染** （`React Native`、`Weex`）

- **`自绘 UI`** + **原生** (`Qt for mobile`、`Flutter`)

## 原生开发

原生应用程序是指某一个移动平台（比如 `iOS` 或 `Android` ）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的 `SDK API`。

比如 `Android` 原生应用就是指使用 `Java` 或 `Kotlin` 语言直接调用 `Android SDK` 开发的应用程序；

而 `iOS` 原生应用就是指通过 `Objective-C` 或 `Swift` 语言直接调用 `iOS SDK` 开发的应用程序。

### 优势

- 可访问平台 **全部功能**（`GPS`、摄像头）；

- **速度快、性能高、可以实现复杂动画及绘制，整体用户体验好**；

### 弊端

- 平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大；

- 内容固定，动态化弱，大多数情况下，有新功能更新时只能发版；

## Hybrid

这类框架主要原理就是将 `App` 中需要动态变动的内容通过 `HTML5`（简称 H5）来实现，通过原生的网页加载控件 `WebView` 来加载。

这种方案中，`H5` 部分是可以随时改变而不用发版，动态化需求能满足；

同时，由于 `H5` 代码只需要一次开发，就能同时在 `Android` 和 `iOS` 两个平台运行，这也可以减小开发成本，也就是说，`H5` 部分功能越多，开发成本就越小。

我们称这种 **H5 + 原生** 的开发模式为混合开发 ，采用混合模式开发的 `App` 我们称之为混合应用或 `HTMLybrid App` ，如果一个应用的大多数功能都是 `H5` 实现的话，我们称其为 `Web App` 。

### 优势

- `Hybrid` 的优点是动态内容是 `H5`，`Web` 技术栈，社区及资源丰富;

### 弊端

- 性能体验不佳，对于复杂用户界面或动画，`WebView` 有时会不堪重任；

## JavaScript 开发 + 原生渲染

虚拟 `DOM` 的盛行，带来了跨平台的便利，以 `React` 为例，虚拟 `DOM` 最终映射为**浏览器 `DOM` 树**，而在 `RN` 中，虚拟 `DOM` 会通过 `JavaScriptCore` 映射为**原生控件**。

`JavaScriptCore` 是一个 `JavaScript` 解释器，它在 `React Native` 中主要有两个作用：

1. 为 `JavaScript` 提供运行环境。

2. 是 `JavaScript` 与原生应用之间通信的桥梁，作用和 `JsBridge` 一样，事实上，在 `iOS` 中，很多 `JsBridge` 的实现都是基于 `JavaScriptCore` 。

至此，`React Native` 便实现了跨平台。 相对于混合应用，由于 `React Native` 是 原生控件渲染，所以性能会比混合应用中 `H5` 好一些，同时 `React Native` 提供了很多原生组件对应的 `Web` 组件，大多数情况下开发者只需要使用 `Web` 技术栈 就能开发出 `App`。

### 优势

- 采用 `Web` 开发技术栈，**社区庞大**、**上手快**、**开发成本相对较低**。

- **原生渲染**，性能相比 `H5` 提高很多。

- **动态化较好**，支持热更新。

### 弊端

- 渲染时需要 `JavaScript` 和原生之间通信，在有些场景如拖动可能会因为**通信频繁导致卡顿**。

- `JavaScript` 为脚本语言，执行时需要 **解释执行** （这种执行方式通常称为 `JIT`，即 Just In Time，指在执行时实时生成机器码），执行效率和**编译类语言**（编译类语言的执行方式为 `AOT` ，即 Ahead Of Time，指在代码执行前已经将源码进行了预处理，这种预处理通常情况下是将源码编译为机器码或某种中间码）仍有差距。

- 由于渲染 **依赖原生控件**，不同平台的控件 **需要单独维护**，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生 `UI` 系统限制，例如，在 `Android` 中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。这就会导致，如果需要自定义原生渲染组件时，开发和维护成本过高。

## 自绘 UI + 原生

通过在不同平台实现一个 **统一接口的渲染引擎绘制 `UI`** ，而不依赖系统原生控件，所以可以做到不同平台 `UI` 的一致性。

<div class="Alert">

自绘引擎解决的是 `UI` 的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发

</div>

### 优势

- 性能高；由于自绘引擎是直接调用系统 `API` 来绘制 `UI`，所以性能和原生控件接近。

- 灵活、组件库易维护、`UI` 外观保真度和一致性高；由于 UI 渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。

- 开发效率高，以 `flutter` 的热更新为例，当真让原生开发的伙伴感到惊讶。

### 弊端

- 动态不足，但并非是不可以。

- 需要一点学习成本，以 `flutter` 为例，使用 `dart`,`Qt` 则使用 `C++`

## 对比

<table> 
   <thead> 
    <tr> 
     <th>技术类型</th> 
     <th>UI渲染方式</th> 
     <th>性能</th> 
     <th>开发效率</th> 
     <th>动态化	</th> 
     <th>框架代表</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>H5 + 原生</td> 
     <td>WebView渲染</td> 
     <td>一般</td> 
     <td>高</td> 
     <td>支持</td> 
     <td>Cordova、Ionic</td> 
    </tr> 
     <tr> 
     <td>JavaScript + 原生渲染</td> 
     <td>原生控件渲染</td> 
     <td>好</td> 
     <td>中</td> 
     <td>支持</td> 
     <td>RN、Weex</td> 
    </tr> 
         <tr> 
     <td>自绘UI + 原生</td> 
     <td>调用系统API渲染</td> 
     <td>好</td> 
     <td>Flutter高, Qt低</td> 
     <td>默认不支持</td> 
     <td>Qt、Flutter</td> 
    </tr> 
   </tbody> 
  </table>

<div class="Alert">

动态化主要指是否支持动态下发代码和是否支持热更新。值得注意的是 `Flutter` 的 `Release` 包默认是使用 `Dart AOT` 模式编译的，所以不支持动态化，但 `Dart` 还有 `JIT` 或 `snapshot` 运行方式，这些模式都是支持动态化的。

</div>
