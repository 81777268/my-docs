<!--
 * @Author: your name
 * @Date: 2021-11-30 14:51:33
 * @LastEditTime: 2021-11-30 16:55:28
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /my-docs/docs/569795345.md
-->

## Babel 的出现

说起 `ES6`，`webpack`，打包，模块化总是离不开 `babel`，`babel` 作为一个 `js` 的编译器已经被广泛使用。在 `babel` 的官网是这样介绍它的：

> Babel is a JavaScript compiler.

> Use next generation JavaScript, today.

大家都知道 `js` 作为宿主语言，很依赖执行的环境（浏览器、node 等），不同环境对 `js` 语法的支持不尽相同，特别是 `ES6` 之后，`ECMAScrip` 对版本的更新已经到了一年一次的节奏，虽然每年更新的幅度不大，但是每年的提案可不少。

`babel` 的出现就是为了解决这个问题，把那些使用新标准编写的代码转译为当前环境可运行的代码，简单点说就是把 `ES6` 代码转译（转码+编译）到 `ES5`。

### ES6

正文之前先谈谈 `ES6`，`ES` 即 `ECMAScript`，`6` 表示第六个版本(也被称为是 `ES2015`，因为是 `2015` 年发布的)，它是 `javascript` 的实现标准。

**被纳入到 `ES` 标准的语法必须要经过如下五个阶段:**

**Stage 0**: `strawman`

**Stage 1**: `proposal`

**Stage 2**: `draft` - 必须包含 `2` 个实验性的具体实现，其中一个可以是用转译器实现的，例如 `Babel`。

**Stage 3**: `candidate` - 至少要有 `2` 个符合规范的具体实现。

**Stage 4**: `finished`

<div class="Alert Alert--point">

可以看到提案在进入 `stage3` 阶段时就已经在一些环境被实现，在 `stage2` 阶段有 `babel` 的实现。所以被纳入到 `ES` 标准的语法其实在大部分环境都已经是有了实现的，那么为什么还要用 `babel` 来进行转译，因为不能确保每个运行代码的环境都是最新版本并已经实现了规范。

</div>

### Babel 的版本变更

至此 `babel` 版本已经到了 `7.16.0` ，我们先从使用最广也是最稳定的 `babel6` 来开始说，看一看渐进到 `7.x` 到底更改了哪些。

在 `babel5` 的时代，`babel` 属于全家桶型，只要安装 `babel` 就会安装 `babel` 相关的所有工具， 即装即用。

但是到了 `babel6`，具体有以下几点变更：

- 移除 `babel` 全家桶安装，拆分为单独模块，例如：`babel-core`、`babel-cli`、`babel-node`、`babel-polyfill` 等；

- 新增 `.babelrc` 配置文件，基本上所有的 `babel` 转译都会来读取这个配置；

- 新增 `plugin` 配置，所有的东西都插件化，什么代码要转译都能在插件中自由配置；

- 新增 `preset` `配置，babel5` 会默认转译 `ES6` 和 `jsx` 语法，`babel6` 转译的语法都要在 `perset` 中配置， **`preset` 简单说就是一系列 `plugin` 包的使用** 。

## babel 6.x 模块与配置

`babel6` 将 `babel` 全家桶拆分成了许多不同的模块，只有知道这些模块怎么用才能更好的理解 `babel`。

安装方式：

```js
//通过npm安装
npm install babel-core babel-cli babel-node

//通过yarn安装
yarn add babel-core babel-cli babel-node
```

### babel-core

顾名思义，`babel-core` 是 `Babel` 的核心模块，`Babel` 核心的 `API` 都是由此模块提供。如 `transform`、`transformFile`、`transformFileSync` 等。

此模块主要功能是通过读取配置文件或者传入的配置参数将源代码转换成我们需要的代码。

当我们需要对代码做转码的时候，就需要使用此模块。如

```js
var es6Code = 'let x = n => n + 1'
var es5Code = require('babel-core').transform(es6Code, {
  presets: ['es2015'],
}).code

// 编译后
var x = function x(n) {
  return n + 1
}
```

其次在构建打包工具中，如 `webpack` 的 `babel-loader` 插件也会使用到 `Babel API`，将源码传入 `transform` 方法中。

```js
var babel = require('babel-core')

// ...
var transpile = function transpile(source, options) {
  //some code
  try {
    result = babel.transform(source, options) // transform 方法
  } catch (error) {
    //some codes
  }
  //some codes
}
```

### babel-cli

`babel-cli` 是一个通过命令行对 `js` 文件进行换码的工具。

使用方法：

- 直接在命令行输出转译后的代码

```js
babel script.js
```

- 指定输出文件

```js
babel script.js --out-file build.js
//或者是
babel script.js -o build.js
```

让我们来编写了一个具有箭头函数的代码：

```js
//命令 babel --plugins transform-es2015-arrow-functions main.js -o build.js
//main.js
const array = [1, 2, 3].map((item, index) => item * 2)
// build.js
const array = [1, 2, 3].map(function (item, index) {
  return item * 2
})
```

或者在目录里添加一个`.babelrc` 文件，内容如下：

```js
{
    "plugins": [
        "transform-es2015-arrow-functions"
    ]
}
```

`.babelrc` 是 `babel` 的全局配置文件，所有的 `babel` 操作（包括 `babel-core`、`babel-node`）基本都会来读取这个配置，后面会详细介绍

### babel-node

`babel-node` 是随 `babel-cli` 一起安装的，只要安装了 `babel-cli` 就会自带 `babel-node`。

在命令行输入 `babel-node` 会启动一个 `REPL`（`Read-Eval-Print-Loop`），这是一个支持 `ES6` 的 `js` 执行环境。

```js
// bash babel-node
babel > [1, 2, 3].map((item) => item * 3)

babel > [(3, 6, 9)]
```

<div class="Alert">

其实不用 `babel-node`，直接在 `node` 下，只要 `node` 版本大于 `6` 大部分 `ES6` 语法已经支持。

</div>

`babel-node` 还能直接用来执行 `js` 脚本，与直接使用 `node` 命令类似，只是会在执行过程中进行 `babel` 的转译，并且 `babel` 官方不建议在生产环境直接这样使用，因为 `babel` 实时编译产生的代码会缓存在内存中，导致内存占用过高，所以我们了解了解就好。 [参考文档](https://www.babeljs.cn/docs/babel-register#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)

```js
babel-node script.js
```

### babel-register

`babel-register` 字面意思能看出来，这是 `babel` 的一个注册器，它在底层改写了 `node` 的 `require` 方法，引入 `babel-register` 之后所有 `require` 并以 `.es6`, `.es`, `.jsx` 和 `.js` 为后缀的模块都会经过 `babel` 的转译

`babel-register` 与 `babel-core` 会同时安装，在 `babel-core` 中会有一个 `register.js` 文件，所以引入 `babel-register` 有两种方法：

```js
require('babel-core/register')
require('babel-register')
```

<div class="Alert">

但是官方不推荐第一种方法，因为 `babel-register` 已经独立成了一个模块，在 `babel-core` 的 `register.js` 文件中有如下注释。

> TODO: eventually deprecate this console.trace("use the babel-register package instead of babel-core/register");

</div>

### babel-polyfill

`polyfill` 这个单词翻译成中文是垫片的意思，详细点解释就是桌子的桌脚有一边矮一点，拿一个东西把桌子垫平。

`polyfill` 在代码中的作用主要是用已经存在的语法和 `api` 实现一些浏览器还没有实现的 `api`，对浏览器的一些缺陷做一些修补。

例如 `Array` 新增了 `includes` 方法，我想使用，但是低版本的浏览器上没有。

```js
if (!Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    value: function (searchElement, fromIndex) {
      if (this == null) {
        throw new TypeError('"this" is null or not defined')
      }
      var o = Object(this)
      var len = o.length >>> 0
      if (len === 0) {
        return false
      }
      var n = fromIndex | 0
      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0)
      while (k < len) {
        if (o[k] === searchElement) {
          return true
        }
        k++
      }
      return false
    },
  })
}
```

<div class="Alert">

上面简单的提供了一个 `includes` 方法的 `polyfill`，代码来自 `MDN`。

</div>

理解 `polyfill` 的意思之后，再来说说 `babel` 为什么存在 `polyfill`。

因为 `babel` 的 **转译只是语法层次** 的转译，例如 **箭头函数**、**解构赋值**、 **`class`** ，对一些新增 `api` 以及全局函数（例如：`Promise`）无法进行转译，这个时候就需要在代码中引入 `babel-polyfill`，让代码完美支持 `ES6+` 环境。

<div class="Alert">

前面介绍的 `babel-node` 就会自动在代码中引入 `babel-polyfill` 包。

</div>

```js
//在代码的最顶部进行require或者import
require('babel-polyfill')
// or
import 'babel-polyfill'

//如果使用webpack，也可以在文件入口数组引入
module.exports = {
  entry: ['babel-polyfill', './app/js'],
}
```

<div class="Alert">

但很多时候我们并不会使用所有 `ES6+` 语法，全局添加所有垫片肯定会让我们的代码量上升，之后会介绍其他添加垫片的方式。

</div>

### babel 配置

前面已经介绍了 `babel` 常用的一些模块，接下来看看 `babel` 的配置文件 `.babelrc`。

<div class="Alert Alert--point">

后面的后缀 `rc` 来自 `linux` 中，使用过 `linux` 就知道 `linux` 中很多 `rc` 结尾的文件，比如 `.bashrc`，`rc` 是 **`run command`** 的缩写，翻译成中文就是 **运行时的命令**，表示程序执行时就会来调用这个文件。

</div>

`babel` 所有的操作基本都会来读取这个配置文件，除了一些在回调函数中设置 `options` 参数的，如果没有这个配置文件，会从 `package.json` 文件的 `babel` 属性中读取配置。

#### plugins

先简单介绍下 `plugins` ，`babel` 中的插件，通过配置不同的插件才能告诉 `babel`，我们的代码中有哪些是需要转译的。

```js
{
    "plugins": [
        "transform-es2015-arrow-functions", //转译箭头函数
        "transform-es2015-classes", //转译class语法
        "transform-es2015-spread", //转译数组解构
        "transform-es2015-for-of" //转译for-of
    ]
}
//如果要为某个插件添加配置项，按如下写法：
{
    "plugins":[
        //改为数组，第二个元素为配置项
        ["transform-es2015-arrow-functions", { "spec": true }]
    ]
}
```

上面这些都只是 **语法层次的转译**，前面说过有些 `api` 层次的东西需要引入 `polyfill`，同样 `babel` 也有一系列插件来支持这些。

```js
{
    "plugins":[
        //如果我们在代码中使用Object.assign方法，就用如下插件
        "transform-object-assign"
    ]
}

//写了一个使用Object.assign的代码如下：
const people = Object.assign({}, {
    name: 'hi'
});
//经过babel转译后如下：
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

const people = _extends({}, {
    name: 'hi'
});
```

<div class="Alert">

这种通过 `transform` 添加的 `polyfill` 只会引入到当前模块中，试想实际开发中存在多个模块使用同一个 `api`，每个模块都引入相同的 `polyfill`，大量重复的代码出现在项目中，这肯定是一种灾难。

另一个个的引入需要 `polyfill` 的 `transform` 挺麻烦的，而且不能保证手动引入的 `transform` 一定正确，稍后会提供一个解决方案： **`transform-runtime`** 。

</div>

除了添加 `polyfill`，`babel` 还有一个工具包 `helpers`。

这个工具包类似于 `babel` 的 `utils` 模块，就像我们项目中的 `utils` 一样，很多地方都会用到，例如 `babel` 实现 `Object.assign` 就是使用的 `helpers` 中的`_extend` 方法。

为了避免同一个文件多次引用 `babel` 的助手函数，通过 `external-helpers` 插件，能够把这些助手函数抽出放到文件顶部，避免多次引用。

<div class="Alert">

虽然这个插件能避免一个文件多次引用助手函数，但是并不能直接避免多个文件内重复引用，这与前面说到的通过 `transform` 添加 `polyfill` 是一样的问题，

</div>

在说完 `babel` 的 `helpers` 之后就到了插件系统的最后的一个插件：`transform-runtime`。

前面在 `transform-polyfill` 的时候也有提到这个插件，之所以把它放到 `helpers` 后面是因为这个插件能自动为项目引入 `polyfill` 和 `helpers`。

`transform-runtime` 这个插件依赖于 `babel-runtime`，所以安装 `transform-runtime` 的同时最好也安装 `babel-runtime`，为了防止一些不必要的错误。

`babel-runtime` 由三个部分组成：

- **core-js**

> core-js 极其强悍，通过 ES3 实现了大部分的 ES5、6、7 的垫片，作者 zloirock 是来自战斗名族的程序员，一个人维护着 core-js，听说他最近还在找工作，上面是 core-js 的 github 地址，感兴趣可以去看看。

- **regenerator**

> regenerator 来自 facebook 的一个库，用于实现 generator functions。

- **helpers**

> babel 的一些工具函数，没错，这个 helpers 和前面使用 babel-external-helpers 生成的 helpers 是同一个东西

安装有 babel-runtime 之后要引入 helpers 可以使用如下方式：

```js
require('babel-runtime/helpers')
```

使用 `runtime` 的时候还有一些配置项：

```js
{
    "plugins": [
        ["transform-runtime", {
            "helpers": false, //自动引入helpers
            "polyfill": false, //自动引入polyfill（core-js提供的polyfill）
            "regenerator": true, //自动引入regenerator
        }]
    ]
}
```

`babel-plugin-transform-runtime` 插件可以通过引用 `babel-runtime` 库来避免重复注入辅助函数：

```js
class Circle {}

// 语法会转换成
function _classCallCheck(instance, Constructor) {
  //...
}

// 导入 @babel/runtime/helpers/classCallCheck
var _classCallCheck = require('babel-runtime/helpers/classCallCheck')

var Circle = function Circle() {
  _classCallCheck(this, Circle)
}
```

**比较 `transform-runtime` 与 `babel-polyfill` 引入垫片的差异：**

1. 使用 `runtime` 是按需引入，需要用到哪些 `polyfill`，`runtime` 就自动帮你引入哪些，不需要再手动一个个的去配置 `plugins`，只是引入的 `polyfill` 不是全局性的，有些局限性。而且 `runtime` 引入的 `polyfill` 不会改写一些实例方法，比如 `Object` 和 `Array` 原型链上的方法，像前面提到的 `Array.protype.includes`。

2. `babel-polyfill` 就能解决 `runtime` 的那些问题，它的垫片是全局的，而且全能，基本上 `ES6` 中要用到的 `polyfill` 在 `babel-polyfill` 中都有，它提供了一个完整的 `ES6+ 的环境`。`babel` 官方建议只要不在意 `babel-polyfill` 的体积，最好进行全局引入，因为这是最稳妥的方式。

3. 一般的建议是开发一些框架或者库的时候使用不会污染全局作用域的 `babel-runtime`，而开发 `web` 应用的时候可以全局引入 `babel-polyfill` 避免一些不必要的错误，而且大型 `web` 应用中全局引入 `babel-polyfill` 可能还会减少你打包后的文件体积（相比起各个模块引入重复的 `polyfill` 来说）。

#### presets

显然这样一个一个配置插件会非常的麻烦，为了方便，`babel` 为我们提供了一个配置项叫做 `persets`（预设）。

如果要转译 `ES6` 语法，只要按如下方式配置即可：

```js
{
    "presets": ["es2015"]
}

//如果要转译的语法不止ES6，还有各个提案阶段的语法也想体验，可以按如下方式。
{
    "presets": [
        "es2015",
        "stage-0",
        "stage-1",
        "stage-2",
        "stage-3",
    ]
}

//同样babel也能直接转译jsx语法，通过引入react的预设
{
    "presets": [
        "es2015",
        "react"
    ]
}
```

**不过上面这些 `preset` 官方现在都已经不推荐了，官方唯一推荐 `babel-preset-env`。**

这款 `preset` 能灵活决定加载哪些插件和 `polyfill`，不过还是得开发者手动进行一些配置。

```js
{
    "presets": [
        ["env", {
            "targets": { //指定要转译到哪个环境
                //浏览器环境
                "browsers": ["last 2 versions", "safari >= 7"],
                //node环境
                "node": "6.10", //"current"  使用当前版本的node

            },
             //是否将ES6的模块化语法转译成其他类型
             //参数："amd" | "umd" | "systemjs" | "commonjs" | false，默认为'commonjs'
            "modules": 'commonjs',
            //是否进行debug操作，会在控制台打印出所有插件中的log，已经插件的版本
            "debug": false,
            //强制开启某些模块，默认为[]
            "include": ["transform-es2015-arrow-functions"],
            //禁用某些模块，默认为[]
            "exclude": ["transform-es2015-for-of"],
            //是否自动引入polyfill，开启此选项必须保证已经安装了babel-polyfill
            //参数：Boolean，默认为false.
            "useBuiltIns": false
        }]
    ]
}
```

<div class="Alert">

关于最后一个参数 `useBuiltIns`，有两点必须要注意：

如果 `useBuiltIns` 为 `true`，项目中必须引入 `babel-polyfill`。

`babel-polyfill` 只能被引入一次，如果多次引入会造成全局作用域的冲突。

</div>

## babel 7 的升级与配置

`Babel` 团队在 **2018 年 9 月** 正式发布 `Babel 7`，加了许多新特性，并且做了较大的变更。

虽然此次的改动对升级造成更多的困难，但是个人觉得 `Babel 7` 更加符合 `EcmaScript` 及目前一些流行框架语言的发展趋势，更加适应于未来。

### Babel 7 新加特性

`Babel 7` 在编译速度上表现的更加优秀，并且加了一些新的功能，如支持编译 `TypeScript`；支持 `JSX Fragment`（针对 `React` 的 `Fragment` 特性）；支持自动引用 `polyfill` 等。

### 自动引用 polyfill

对于新加的功能，这里只对自动引入 `polyfill` 做下介绍，因为这个功能比较常用。

<div class="Alert Alert--point">

`Babel 7` 用了 `npm` 的 `private scope`，把全部的包都挂在在 `@babel` 下，类似的有 `typescript` 的 `@type`。

</div>

这个功能是基于 `@babel/preset-env` 就是上文介绍到的 `babel-preset-env` 插件。

在 `Babel 7` 发布之后，这个插件的 `useBuiltIns` 配置属性新增了可选项，以支持使用更多的方式来处理 `polyfill`。

- `useBuiltIns: entry`

如果使用这个选项，需要在入口文件中引入 `@babel/polyfill`，`Babel` 将会根据指定的环境自动将 `@babel/polyfill` 打散成单独的模块引入。

```js
// 入口文件
import '@babel/polyfill'
// 经过 Babel 后输出，这里会根据当前指定的环境是否已经支持来决定引入哪些模块
import 'core-js/modules/es7.string.pad-start'
import 'core-js/modules/es7.string.pad-end'
// .....
```

- `useBuiltIns: usage`

相比于 `entry`，这个属性会更强大一些。我们不需要手动引入 `@babel-polyfill`，并且 `Babel` 会对每个文件做判断决定是否引入 `polyfill`。

```js
// 我们在这个文件使用到了 Promise
const a = new Promise()

// 如果浏览器是不支持的
import 'core-js/modules/es6.promise' //自动引入
var a = new Promise()

// 如果浏览器支持
var a = new Promise()
```

### 断崖式变更

除了新加的功能外，相比于 `Babel 6`，`Babel 7` 对原有的一些功能做了较大的调整。以下是需要特别注意的改动点，根据这些改动，我们能更好的做好升级工作。

1. `Babel` 官方的依赖包都放在 `@babel` 作用域下。如 `babel-runtime`，在 `Babel 7` 以后要以 `@babel/runtime` 方式使用。

2. `presets` 废弃 `stage-0`、`stage-1`、`stage-2`、`stage-3`，推荐以插件的形式引入，如 `@babel/plugin-proposal-decorators`；

3. `babel-runtime` 被拆分为 `@babel/runtime` 以及 `@babel/runtime-corejs2`。前者只保留了 `regenerator-runtime` 和 `helpers`，后者同时还保留了 `polyfill`，与之前的 `babel-runtime` 基本一样。

4. `polyfill` 移除了处于提议中的特性，需要单独引入依赖包。如目前还处于 `stage-3` 的 `String.prototype.matchAll` 方法， 需要用 `import "core-js/fn/string/match-all"`方式引入。

### 升级要点

[参考](https://zhuanlan.zhihu.com/p/146682865)
