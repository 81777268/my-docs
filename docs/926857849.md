## 函数特征

`compose` 是函数式编程中使用较多的一种写法，它把逻辑解耦在各个函数中，通过 `compose` 的方式组合函数，将外部数据依次通过各个函数的加工，生成结果。

1. **后一个函数作为前一个函数的参数**

2. **最后一个函数可以接受多个参数，前面的函数只能接受单个参数，后一个的返回值传给前一个**

## 栗子

```js
// 这个运算有两个操作，先做加法运算，再做幂运算
let f = (x) => (5 + x) ^ 3;

// 拆分解耦
function power(x) {
  return Math.pow(x, 10);
}
function add(x) {
  return x + 5;
}

// compose 化
function compose(fn1, fn2) {
  return function (x) {
    return fn1(fn2(x));
  };
}

// 可简写成
const compose = (fn1, fn2) => (x) => fn1(fn2(x));
compose(power, add)(5); // 1000
```

这是两个函数 `compose` 的实现方式

如果有 `N` 个函数呢，难道每次要写成:

```js
// 伪代码
const compose = (f1, ..., fn) => x => f1(...(fn(x)))
```

## reduce 实现

> [Array.prototype.reduce](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) 这个方法会对数组中的每个元素执行一个由你提供的 `reducer` 函数(升序执行)，将其结果汇总为单个返回值。

```js
function compose(...funs) {
  return function (...args) {
    let len = funs.length;
    if (len === 0) {
      return args;
    }
    if (len === 1) {
      return funs[0](...args);
    }
    return funs.reduce((x, y) => {
      return typeof x === "function" ? y(x(...args)) : y(x);
    });
  };
}
```

## 迭代方式

```js
function compose(...fns) {
  const len = fns.length;

  // 检查所有参数是否为函数
  let index = len;
  while (index--) {
    if (typeof fns[index] !== "function") {
      throw new TypeError("Expected a function");
    }
  }

  return function (...args) {
    let index = 0;
    var reslut = len ? fns[index].apply(this, args) : args;
    while (++index < len) {
      reslut = fns[index].call(this, reslut);
    }
    return reslut;
  };
}
```
