<!--
 * @Author: xl
 * @Date: 2022-01-22 18:29:31
 * @LastEditors: xl
 * @LastEditTime: 2022-01-22 22:34:04
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /my-docs/docs/19361152.md
-->

> `BitMap` 是用 `bit` 位来记录数据存在与否的一种算法。在处理大数据时，可以节省大量空间，速度也很快。

## 为什么需要 bitMap

我们先以一个栗子，来说明 `bitmap` 的使用场景：

写一个存储结构，要求存储 `100` 个正整数，并且提供两种方法，添加与查询，常用的 **方案一**：

```js
function FindClass() {
  var datas = [] //存储数据
  this.addMember = function (member) {
    datas.push(member)
  }
  //isExist 的实现方式2
  this.isExist = function (member) {
    if (datas.indexOf(member) >= 0) {
      return true
    }
    return false
  }
}
```

**方案二**：

```js
function FindClass() {
  var datas = new Array(100)
  //先都初始化为0
  for (let i = 0; i < datas.length; i++) {
    datas[i] = 0
  }
  //添加一个整数
  this.addMember = function (member) {
    datas[i] = 1
  }
  //判断member是否存在
  this.isExist = function (member) {
    if (datas[member] == 1) {
      return true
    } else {
      return false
    }
  }
}
```

<div class="Alert Alert--point">

相比较于方案一，方案二以索引的方式记录存在的值，这样时间复杂度由 `O(n)` 降到了 `O(1)`

</div>

但是方案二也会有另一个问题，那就是储存空间！

如果我们的 **数据量很大**，每个整数是 `4` 个字节，那么如果数据有 `1` 亿，对应就要储存 `381M` 的数据，显然这是中很浪费内存的行为，那么如何解决呢？答案是： **`bitMap`** !

## bitMap 是什么

我们还是先以一个栗子进入：

街边有 8 栈路灯，编号分别为 1 2 3 4 5 6 7 8，其中 2 号、5 号、7 号、8 号路灯是亮着的。其它是不亮的。

该如何表示？

答案是二进制：

```js
 1 2 3 4 5 6 7 8
 0 1 0 0 1 0 1 1
```

<div class="Alert Alert--point">

在这之前，可以优先了解一下在 `JS` 中 `Number` 的储存，[64 位双精度浮点数](https://zhuanlan.zhihu.com/p/351127362)，便于理解。

</div>

仅 `8` 个 `bit` 位就能表示 `8` 栈路灯的亮灭情况。一个整数有 `32` 个 `bit` 位，就可以表示 `32` 栈路灯的亮灭 情况。

> 一个整数占用 `4` 个字节，每个字节即 `8 bit` 位

回归上面的问题，上述中的 `isExist` 方法要判断一个数是否存在，是不是也可以借助这种方式呢？

假设 `value` 是一个 `int` 类型的的数据，初始化为 `0`，当 `addMember` 传进来的参数为 `0` 的时候，就把 `value` 的二进制第一个设置为 `1`.

此时 `value = 1`,
如果又增加了一个 `3`，就把 `value` 的二进制的第四位设置为 `1`

```js
 00000000 00000000 00000000 00001001
```

此时上面的二进制可以用十进制的 `9` 来表示，即：`value = 9`,`9` 可以表示 `0` 和 `3` 都存在。

一个整数可以表示 `0-31` 的存在与否，如果创建一个大小为 `10` 的数组，数组里存储整数，那么这个数组就可以表示 `0-319` 的存在与否

`datas[0]` 表示 `0-31` 存在与否

`datas[1]` 表示 `32-63` 存在与否

。
。
。

`datas[9]` 表示 `288-319` 存在与否

通过这种方式，就可以把空间的使用降到原来的 1/32，存储 `1` 亿个整数的存在与否，只需要 `12M` 的内存空间。

## 二进制的位运算

- 按位与（&）

两个整数进行按位与运算，相同二进制位的数字如果都是 `1`，则结果为 `1`，有一个为 `0`，则结果为 `0`。 如 `3&7` 的计算：

```js
0 1 1 --  3
1 1 1 --  7
0 1 1 --  3

//  即
3 & 7 = 3
```

- 按位或 （|）

两个整数按位或运算，相同二进制的数字如果有一个为 `1`，则结果为 `1`，都为 `0`，则结果为 `0` 。 如 `5 | 8`的计算：

```js
 0 1 0 1  --  5
 1 0 0 0  --  8

 1 1 0 1  --  13
 // 即
 5|8=13
```

- 左移操作 （<<）

二进制向左移动 `n` 位，在后面添加 `n` 个 `0`，下面是 `3<<1` 的计算过程：

```js
    0 1 1   --  3
  0 1 1 0   --  6
  // 即
  3<<1 = 6
```

举一个栗子：

一组数，内容为 3 9 19 20 ，请用一个整数来表示这四个数。

```js
var value = 0
value = value | (1 << 3)
value = value | (1 << 9)
value = value | (1 << 19)
value = value | (1 << 20)
console.log(value) //1573384
```

## bitMap 实现

现在我们重新设计一个类，实现 `addMember` 和 `isExist` 方法，用更快的速度，更少的内存。

- 数据范围是 `0-100`，那么只需要 `4` 个整数就可以表示 `4*32` 个数的存在与否，创建一个大小为 `4` 的数组。

- 执行 `addMember` 时，先用 `member/32`，确定 `member` 在数组里的索引（`arr_index`）,然后用 `member%32`，确定在整数的哪个二进制位进行操作（`bit_index`）， 最后执行 `bit_arr[arr_index] = bit_arr[arr_index] | 1 << bit_index`

- 执行 `isExist` 时，先用 `member/32`，确定 `member` 在数组里的索引（`arr_index`）,然后用 `member%32`，确定在整数的哪个二进制位进行操作（`bit_index`），最后执行 `bit_arr[arr_index] = bit_arr[arr_index] & 1 << bit_index`;如果结果不为 `0`，就说明 `member` 存在。

```js
function BitMap(size) {
  var bit_arr = new Array(size)
  for (var i = 0; i < bit_arr.length; i++) {
    bit_arr[i] = 0
  }
  this.addMember = function (member) {
    //决定在数组中的索引
    var arr_index = Math.floor(member / 32)
    //决定在整数的32个bit位的哪一位
    var bit_index = member % 32
    bit_arr[arr_index] = bit_arr[arr_index] | (1 << bit_index)
  }
  this.isExist = function (member) {
    var arr_index = Math.floor(member / 32)
    var bit_index = member % 32
    var value = bit_arr[arr_index] & (1 << bit_index)
    if (value != 0) {
      return true
    }
    return false
  }
}
```

这种数据结构 **基于位做映射**，能用很少的内存存储数据，和数组不同，他 **只能表示某个数是否存在**，可以用于 **大数据去重**、**大数据排序**、**两个集合取交集**。

`BitMap` 在处理大数据时才有优势，而且要求数据集紧凑，如果处理的数据只有 `3` 个 `1`，`1000`，`100000`，那么空间利用率太低了，最大的值决定了 `BitMap` 要用多少内存。

## 举起一个大栗子

来一个大数据排序：

有多达 `10` 亿个无序整数，已知最大值为 `15` 亿，请对这 `10` 亿个数进行排序。

`BitMap` 存储最大值为 `15` 亿的集合，只需要 `180M` 的空间。位运算的速度非常快的。 （`1500000000 / 8 / 1024 / 1024`）

第一次遍历，将 `10` 亿个数都放入 `bitMap` 中，第二次，从 `0` 到 `15` 亿进行遍历，如果在 `bitMap` 中，则输出该值，这个经历 `2` 次遍历，就可以将如此多的数据排序。

为了方便演示，只用很小的数组 `[0,6,88,7,73,34,10,99,22]` ,已知数组最大值是 `99`，利用 `bitMap` 排序算法如下：

```js
var arr = [0, 6, 88, 7, 73, 34, 10, 99, 22]
var sort_arr = []
var bit_map = new BitMap(4)
for (let i = 0; i < arr.length; i++) {
  bit_map.addMember(arr[i])
}
for (let i = 0; i < 99; i++) {
  if (bit_map.isExist(i)) {
    sort_arr.push(i)
  }
}
console.log(sort_arr)
```
