## LRU 缓存原理

`LRU`（`Least recently used`，**最近最少使用**）算法根据数据的 **历史访问记录** 来进行淘汰数据，其核心思想是“ **如果数据最近被访问过，那么将来被访问的几率也更高** ”。

## 实现

最常见的实现是使用一个 **链表** 保存缓存数据，详细算法实现如下：

![1337859321_3597](./_media/1337859321_3597.png)

1. **新数据插入到链表头部**；

2. **每当缓存命中（即缓存数据被访问），则将数据移到链表头部**；

3. **当链表满的时候，将链表尾部的数据丢弃**。

## 实例

它应该支持以下操作：

1. 获取数据 `get` 和 写入数据 `set` 。

2. 获取数据 `get(key)` - 如果密钥 (`key`) 存在于缓存中，则获取密钥的值（总是正数），否则返回 `-1`。

3. 写入数据 `set(key, value)` - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

4. 清除所有缓存。

<div class="Alert Alert--point">

这个栗子不涉及复杂的算法，使用栈即可。可以使用前端熟悉的数组，或者Map实现。

[ES6 Map](https://es6.ruanyifeng.com/#docs/set-map#Map)

</div>

```js
class LRU {
	constructor(length) {
		this.length = length;
		this.stack = new Map();
	}

	get(key) {
		if (this.stack.has(key)) {
			const _value = this.stack.get(key);
			this.stack.delete(key);
			this.stack.set(key, _value);
			return _value;
		} else return -1;
	}

	set(key, value) {
		if (this.stack.has(key)) {
			this.stack.delete(key);
			this.stack.set(key, value);

		} else if (this.stack.size < this.length) {
			this.stack.set(key, value)
		} else {
			this.stack.set(key, value);
			this.stack.delete(this.stack.keys().next().value)
		}
	}

	clear() {
		this.stack.clear();
	}
}

let lru = new LRU(3);
lru.set('1', 1) // 1
lru.set('2', 2) // 1,2
lru.set('3', 3) // 1,2,3
lru.set('4', 4) // 2,3,4

lru.get('2') // 3,4,2
lru.set('4', 4) // 3,2,4

lru.clear() // {}
```

