<!--
 * @Author: your name
 * @Date: 2021-04-22 16:10:19
 * @LastEditTime: 2021-04-25 16:01:11
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /my-docs/docs/virtualdom.md
-->
## 虚拟 DOM 是什么？

**虚拟 DOM （`Virtual DOM`）** 这个概念相信大家都不陌生。从 `React` 到 `Vue` ，`虚拟 DOM` 为这两个框架都带来了跨平台的能力（`React-Native` 和 `Weex`）。

因为很多人是在学习 `React` 的过程中接触到的 `虚拟 DOM` ，所以为先入为主，认为 `虚拟 DOM` 和 `JSX` 密不可分。其实不然，`虚拟 DOM` 和 `JSX` 固然契合，但 `JSX` 只是 `虚拟 DOM` 的充分不必要条件，`Vue` 即使使用模版，也能把`虚拟 DOM` 玩得很好，同时也有很多人通过 `babel` 在 `Vue` 中使用 `JSX`。

很多人认为 `虚拟 DOM` 最大的优势是 `diff` 算法，减少 `JavaScript` 操作 **真实 `DOM`** 的带来的性能消耗。虽然这是`虚拟 DOM` 带来的一个**优势**，但并不是 **全部**。

`虚拟 DOM` 最大的优势在于 **抽象了原本的渲染过程** ，实现了 **跨平台** 的能力，而不仅仅局限于浏览器的 `DOM`，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI。

回到最开始的问题，虚拟 DOM 到底是什么？

说简单点，就是一个普通的 `JavaScript` 对象，包含了 `tag`、`props`、`children` 三个属性。

```html
<div id="app">
  <p class="text">hello world!!!</p>
</div>
```

上面的 `HTML` 转换为 `虚拟 DOM` 如下：

```js
{
  tag: 'div',
  props: {
    id: 'app'
  },
  chidren: [
    {
      tag: 'p',
      props: {
        className: 'text'
      },
      chidren: [
        'hello world!!!'
      ]
    }
  ]
}
```

该对象就是我们常说的 `虚拟 DOM` 了，因为 `DOM` 是 **树形结构**，所以使用 `JavaScript 对象` 就能很简单的表示。

而 `原生 DOM` 因为浏览器厂商需要实现众多的规范（各种 HTML5 属性、DOM事件），即使创建一个空的 `div` 也要付出 **昂贵的代价**。

`虚拟 DOM` 提升性能的点在于 `DOM` **发生变化** 的时候，通过 `diff 算法` 比对 `JavaScript 原生对象`，计算出 **需要变更** 的 `DOM`，然后只对 **变化** 的 `DOM` 进行操作，而 **不是更新整个视图**。

那么我们到底该如何将一段 HTML 转换为虚拟 DOM 呢？

## 从 h 函数进入

观察主流的虚拟 DOM 库（[snabbdom](https://github.com/snabbdom/snabbdom)、[virtual-dom](https://github.com/Matt-Esch/virtual-dom)），通常都有一个 `h 函数`，也就是 `React` 中的 `React.createElement`，以及 `Vue` 中 `render` 方法中的 `createElement`。

另外 `React` 是通过 `babel` 将 `jsx` 转换为 `h 函数`渲染的形式，而 `Vue` 是使用 `vue-loader` 将模版转为 `h 函数`渲染的形式（*也可以通过 `babel-plugin-transform-vue-jsx` 插件在 `vue` 中使用 `jsx`，本质还是转换为 `h 函数`渲染形式*）。

我们先使用 `babel`，将一段 `jsx` 代码，转换为一段 `js` 代码：

#### 安装 babel 依赖

```sh
npm i -D @babel/cli @babel/core @babel/plugin-transform-react-jsx
```

#### 配置 .babelrc

```js
{
    "plugins": [
        [
            "@babel/plugin-transform-react-jsx",
            {
                "pragma": "h", // default pragma is React.createElement
            }
        ]
    ]
}
```

#### 转译 jsx

在目录下新建一个 `main.jsx`

```js
function getVDOM() {
  return (
    <div id="app">
      <p className="text">hello world!!!</p>
    </div>
  )
}
```

使用如下命令进行转译：

```sh
npx babel main.jsx --out-file main-compiled.js
```

可以看到，最终 `HTML` 代码会被转译成 `h 函数`的渲染形式。`h 函数` 接受是三个参数，分别代表是 `DOM` 元素的 **标签名** 、**属性**、**子节点**，最终返回一个**虚拟 DOM 的对象**。

```js
function getVDOM() {
  return h("div", {
      id: "app"
  }, h("p", {
      className: "text"
  }, "hello world!!!"));
}
```

## 渲染虚拟 DOM

虚拟 DOM可以渲染到多个平台，这里只简单描述一下在 **浏览器环境下** 如何渲染虚拟 DOM。

```js
function setProp (element, key, vlaue) {
  element.setAttribute(
    // className使用class代替
    key === 'className' ? 'class' : key,
    vlaue
  )
}

function setProps (element, props) {
  Object.entries(props).forEach(([key, value]) => {
    setProp(element, key, value)
  })
}

function render(vdom) {
  // 如果是字符串或者数字，创建一个文本节点
  if (typeof vdom === 'string' || typeof vdom === 'number') {
    return document.createTextNode(vdom)
  }
  const { tag, props, children } = vdom
  // 创建真实DOM
  const element = document.createElement(tag)
  // 设置属性
  setProps(element, props)
  // 递归子节点，并获取创建真实DOM，插入到当前节点
  children
    .map(render)
    .forEach(element.appendChild.bind(element))

  // 虚拟 DOM 中缓存真实 DOM 节点
  vdom.dom = element
  
  // 返回 DOM 节点
  return element
}
```

将虚拟 DOM 渲染成真实 DOM 后，只需要插入到对应的根节点即可。

```js
const vdom = <div>hello world!!!</div> // h('div', {}, 'hello world!!!')
const app = document.getElementById('app')
// 调用上面渲染方法
const ele = render(vdom) 
app.appendChild(ele)
```

当然在现代化的框架中，一般会有一个组件文件专门用来 **构造虚拟 DOM**，我们模仿 `React` 使用 `class` 的方式编写组件，然后渲染到页面中。

```js
class Component {
  vdom = null // 组件的虚拟DOM表示
  $el  = null // 虚拟DOM生成的真实节点

  state = {
    text: 'Initialize the Component'
  }
  
  render() {
    const { text } = this.state
    return (
      <div>{ text }</div>
    )
  }
}

function createElement (app, component) {
  const vdom = component.render()
  component.vdom = vdom
  component.$el = render(vdom) // 将虚拟 DOM 转换为真实 DOM
  app.appendChild(component.$el)
}

const app = document.getElementById('app')
const component = new Component
createElement(app, component)
```

## diff算法

`diff` 算法，顾名思义，就是比对新老 `VDOM` 的变化，然后将变化的部分更新到视图上。对应到代码上，就是一个 `diff` 函数，返回一个 `patches` （**补丁**）
。

```js
const before  = h('div', {}, 'before text')
const after   = h('div', {}, 'after text')

const patches = diff(before, after)
```

修改我们之前的组件，增加 `setState` 方法，用于修改组件的内部状态。

```js
class Component {
  vdom = null // 组件的虚拟DOM表示
  $el = null // 虚拟DOM生成的真实节点
  
  state = {
    text: 'Initialize the Component'
  }
  
  // 手动修改组件state
  setState(newState) {
    this.state = {
      ...this.state,
      ...newState
    }
    const newVdom = this.render()
    const patches = diff(this.vdom, newVdom)
    patch(this.$el, patches)
  }

  changeText(text) {
    this.setState({
      text
    })
  }
  
  render() {
    const { text } = this.state
    return (
      <div>{ text }</div>
    )
  }
}
```

当我们调用 `setState` `时，state` 内部状态发生变动，再次调用 `render` 方法就会生成一个新的 `虚拟 DOM 树` ，这样我们就能使用 `diff` 方法计算出新老虚拟 `DOM` 发生变化的部分，最后使用 `patch` 方法，**将变动渲染到视图** 中。

### diff算法的历史

关于 `diff` 算法的最经典的就是 **Matt Esch** 的 `virtual-dom`，以及 `snabbdom`（被整合进 vue 2.0中）。

> 最开始出现的是 virtual-dom这个库，是大家好奇React为什么这么快而搞鼓出来的。它的实现是非常学院风格，通过深度优先搜索与in-order tree来实现高效的diff。它与React后来公开出来的算法是很不一样。

> 然后是cito.js的横空出世，它对今后所有虚拟DOM的算法都有重大影响。它采用两端同时进行比较的算法，将diff速度拉高到几个层次。

> 紧随其后的是kivi.js，在cito.js的基出提出两项优化方案，使用key实现移动追踪及基于key的编辑长度矩离算法应用（算法复杂度 为O(n^2)）。

> 但这样的diff算法太过复杂了，于是后来者snabbdom将kivi.js进行简化，去掉编辑长度矩离算法，调整两端比较算法。速度略有损失，但可读性大大提高。再之后，就是著名的vue2.0 把sanbbdom整个库整合掉了。

> 引用自司徒正美的文章 [去哪儿网迷你React的研发心得](https://segmentfault.com/a/1190000011235844)

