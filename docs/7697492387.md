<!--
 * @Author: your name
 * @Date: 2021-05-11 17:11:15
 * @LastEditTime: 2021-05-13 20:05:08
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /my-docs/docs/7697492387.md
-->

## 面向对象三大特性

**继承**，**封装**，**多态**

## 多态

### 重载

> 重载函数是函数的一种特殊情况，为方便使用，`C++` 允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能。这就是重载函数。

<div class="Alert Alert--point">

重载函数常用来实现功能类似而所处理的数据类型不同的问题。不能只有函数返回值类型不同。

</div>

### JS 中的函数重载

`JS` 中没有真正意义上的函数重载，因为 `JS` 中 **同一作用域** 下的 **同名函数** ，前者会被后者 **覆盖**，但是可通过其他方法间接实现重载同样的效果。

> 重载的本质就是将多个功能相近的函数合并为同一个函数。

### 多态的定义

**多态** 是同一个 **行为** 具有多 **个不同表现形式** 或 **形态** 的能力。

> 在 `JS` 中，由于 `JS` 本身是动态的，天生就**支持多态**。

多态的思想实际上是把 **想做什么** 和 **谁去做** 分开。

多态的最根本好处在于，你不必再向对象询问 **你是什么类型** 而后根据得到的答案调用对象的某个行为，你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。

多态最根本的作用就是通过把 **过程化** 的条件分支语句转化为 **对象的多态性** ，从而消除这些条件分支语句。

### 多态的实现

<div class="Alert Alert--point">

举个例子吧，国王听腻了只有鸭子为他唱歌，他决定搞一个动物合唱团。所以，大臣们搜罗了鸭，鸡，狗等动物，而且还设置了专门的选拔官员测试，选拔官员一声令下：‘唱’，面前的动物就发出了特有的叫声，鸭子嘎嘎嘎，小鸡咯咯咯，小狗汪汪汪......要实现这个功能，我们可以使用如下代码

</div>

```js
function Duck(){}
Duck.prototype.sing = function(){
    console.log('嘎嘎嘎');
}
function Chicken(){}
Chicken.protorype.sing = function(){
    console.log(‘咯咯咯’);
}
function singStart(animal){
    animal.sing();
}
singStart(new Duck());  // 嘎嘎嘎
singStart(new Chicken());  // 咯咯咯
```

可以看出来，由于 `JS` 本身的动态性，在 `JS` 中实现多态更加方便，且更加强大。

## 封装

`JS` 是一种基于对象（`object-based`）的语言，你遇到的所有东西几乎 **都是对象** 。但是，它又不是一种真正的面向对象编程（`OOP`）语言，因为它的语法中没有`class`（类）。

那么，如果我们要把 **属性**（`property`）和 **方法**（`method`），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？

### 生成实例对象的原始模式

```js
let Cat = {
  name: "",
  color: "",
};
```

这是最简单的 **封装**，把两个属性封装在一个对象里面。

<div class="Alert Alert--print">

但是，这样的写法有两个缺点:

1. 如果多生成几个实例，写起来非常麻烦;

2. 实例与原型之间，没有任何办法可以看出有联系。

</div>

### 原始模式的改进

我们可以写一个函数，解决代码重复的问题。

```js
function Cat(name, color) {
  return {
    name: name,
    color: color,
  };
}
```

然后生成实例对象，就等于是在调用函数：

```js
let cat1 = Cat("大毛", "黄色");
let cat2 = Cat("二毛", "黑色");
```

<div class="Alert Alert--print">

这种方法的问题依然是，cat1 和 cat2 之间没有内在的联系，不能反映出它们是同一个原型对象的实例。

</div>

### 构造函数模式

为了解决从 **原型对象** 生成实例的问题，`JS` 提供了一个 **构造函数**（`Constructor`）模式。

所谓 **构造函数**，其实就是一个普通函数，但是内部使用了 `this` 变量。对构 **造函数使** 用 `new` 运算符，就能生成实例，并且 `this` 变量会绑定在实例对象上。

比如，猫的构造函数现在可以这样写：

```js
function Cat(name, color) {
  this.name = name;
  this.color = color;
}

var cat1 = new Cat("大毛", "黄色");
var cat2 = new Cat("二毛", "黑色");
console.log(cat1.name); // 大毛
console.log(cat1.color); // 黄色
```

这时 `cat1` 和 `cat2` 会自动含有一个 `constructor` 属性，指向它们的 **构造函数** 。

```js
console.log(cat1.constructor == Cat); //true
conosle.log(cat2.constructor == Cat); //true
```

`JS` 还提供了一个 `instanceof` 运算符，验证 **原型对象** 与 **实例对象** 之间的关系。

```js
console.log(cat1 instanceof Cat); //true
conosle.log(cat2 instanceof Cat(); //true
```

### 构造函数模式的问题

构造函数方法很好用，但是存在一个 **浪费内存** 的问题。

我们现在为 `Cat` 对象添加一个不变的属性 `type`，再添加一个方法 `eat`。那么，**构造函数 `Cat`** 就变成了下面这样:

```js
function Cat(name, color) {
  this.name = name;
  this.color = color;
  this.type = "猫科动物";
  this.eat = function () {
    alert("吃老鼠");
  };
}
```

还是采用同样的方法，生成实例：

```js
let cat1 = new Cat("大毛", "黄色");
let cat2 = new Cat("二毛", "黑色");
conosle.log(cat1.type); // 猫科动物
cat1.eat(); // 吃老鼠
```

<div class="Alert Alert--porint">

这样做有一个很大的弊端，对于每一个 **实例对象**，`type` 属性和 `eat()` 方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。

</div>

```js
console.log(cat1.eat == cat2.eat); //false
```

### Prototype 模式

JS 规定，每一个 **构造函数** 都有一个 `prototype` 属性，指向另一个对象。这个对象的 **所有属性和方法**，都会被 **构造函数的实例继承**。

我们可以把那些 **不变** 的属性和方法，直接定义在 `prototype` 对象上。

改造构造函数：

```js
function Cat(name, color) {
  this.name = name;
  this.color = color;
}
Cat.prototype.type = "猫科动物";
Cat.prototype.eat = function () {
  console.log("吃老鼠");
};
```

生成实例：

```js
let cat1 = new Cat("大毛", "黄色");
let cat2 = new Cat("二毛", "黑色");
console.log(cat1.type); // 猫科动物
cat1.eat(); // 吃老鼠
```

这时所有实例的 `type` 属性和 `eat()` 方法，其实都是同一个 **内存地址**，指向 `prototype` 对象，因此就提高了运行效率。

```js
console.log(cat1.eat === cat2.eat); //true
```

### Prototype 模式的验证方法

为了配合 `prototype` 属性，`JS` 定义了一些辅助方法，帮助我们使用它。

#### isPrototypeOf

> 这个方法用来判断，某个 `proptotype` 对象和某个实例之间的关系。

```js
console.log(Cat.prototype.isPrototypeOf(cat1)); //true
console.log(Cat.prototype.isPrototypeOf(cat2)); //true
```

#### hasOwnProperty

> 每个实例对象都有一个 `hasOwnProperty` 方法，用来判断某一个属性到底是本地属性，还是继承自 `prototype` 对象的属性。

```js
console.log(cat1.hasOwnProperty("name")); // true
console.log(cat1.hasOwnProperty("type")); // false
```

#### in 运算符

> `in` 运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。

```js
console.log("name" in cat1); // true
console.log("type" in cat1); // true
```

> `in` 运算符还可以用来遍历某个对象的所有属性。

```js
for (var prop in cat1) {
  conosle.log("cat1[" + prop + "]=" + cat1[prop]);
}
```

## 继承

```js
function Animal() {
  this.species = "动物";
}

function Cat(name, color) {
  this.name = name;
  this.color = color;
}
```

继承就是字面意思，以 “动物” 和 “猫” 为例，我们讨论一下有哪几种继承方式，以及他们的利弊。

### 通过构造函数继承

这个方法是最简单的方法，使用 `call` 或 `apply` 方法，将父对象的 `构造函数` 绑定在子对象上。

```js
function Cat(name, color) {
  Animal.apply(this, arguments); // 相当于 this.species = "动物";
  this.name = name;
  this.color = color;
}

let cat1 = new Cat("大毛", "黄色");
console.log(cat1.species); // 动物
```

<div class="Alert Alert--porint">

弊端：

1. 实例并不是父类的实例，只是子类的实例

2. 只能继承父类的实例属性和方法，不能继承原型属性和方法

3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

</div>

### 原型链继承

这种方法更常见，使用 `prototype` 属性。

如果 **猫** 的 `prototype` 对象，指向一个 `Animal` 的实例，那么所有 **猫** 的实例，就能继承 `Animal` 了。

```js
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
let cat1 = new Cat("大毛", "黄色");
console.log(cat1.species); // 动物
```

代码的第一行，我们将 `Cat` 的 `prototype` 对象指向一个 `Animal` 的实例。

```js
Cat.prototype = new Animal();
```

<div class="Alert Alert--porint">

它相当于完全删除了 `prototype` 对象原先的值，然后赋予一个新值。

</div>

```js
Cat.prototype.constructor = Cat;
```

这行的意思?

<div class="Alert Alert--porint">

任何一个 `prototype` 对象都有一个 `constructor` 属性，指向它的**构造函数**。如果没有 "`Cat.prototype = new Animal();"` 这一行，`Cat.prototype.constructor` 是指向 `Cat` 的；加了这一行以后，C`at.prototype.constructor` 指向 `Animal`。

</div>

如果没有添加这行代码会怎么样？

```js
Cat.prototype = new Animal();

// new Animal() 生成实例对象，实例对象的 constructor 属性，会默认调用它prototype对象的constructor属性

//即： (new Animal()).constructor === Animal.prototype.constructor === Animal;

//故： Cat.prototype === Animal

//一旦有 o.prototype = {}; 这句 便代表 更改了 原型对象 所以原型对象 指向的 构造函数 也跟着改了 

//o.prototype.constructor = o;

//这显然造成了混淆，所以需要手动指正，需要上面的那行代码：

Cat.prototype.constructor = Cat;
```

<div class="Alert Alert--porint">

弊端：  

1. 无法实现多继承

2. 来自原型对象的所有属性被所有实例共享

3. 创建子类实例时，无法向父类构造函数传参

4. 要想为子类新增属性和方法，必须要在Cat.prototype = new Animal() 之后执行，不能放到构造器中，否则要被覆盖掉

</div>

### 原型链+借用构造函数

这个方法，其实也很简单，就是简单的将上面的原型链继承与构造函数继承结合起来

```js
function Cat(name, color) {
  Animal.apply(this, arguments); // 相当于 this.species = "动物";
  this.name = name;
  this.color = color;
}

Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
```

<div class="Alert Alert--porint">

弊端：  

调用了两次父类构造函数，生成了两份实例

</div>

### 原型链+借用构造函数的组合继承 修补方法

针对于上一个版本，初始化两次实例，我们这次去掉一次初始化

```js
function Cat(name, color) {
  Animal.apply(this, arguments); // 相当于 this.species = "动物";
  this.name = name;
  this.color = color;
}

Cat.prototype = Animal.prototype;
Cat.prototype.constructor = Cat;
```

<div class="Alert Alert--porint">

弊端：  

虽然这样做可以避免两次实例化，但同样带来了另一个问题，没办法辨别实例是子类还是父类创造的，子类和父类的构造函数指向是同一个。

</div>

### 原型链+借用构造函数的组合继承 修补方法+

针对于上一个版本的问题，我们使用 `let B = Object.create(A)`的办法，让子类和父类的构造函数指的并非是同一个。

```js
function Cat(name, color) {
  Animal.apply(this, arguments); // 相当于 this.species = "动物";
  this.name = name;
  this.color = color;
}

Cat.prototype = Object.create(Animal.prototype);
Cat.prototype.constructor = Cat;
```

### ES6中class的继承

**通过 `extends` 关键字实现继承**

```js
class Animal {
    // 调用类的构造方法
    constructor(species){
        this.species = species
    }
}

class Cat extends Animal{
    constructor(name, color, species){
        super(species);
        this.name = name;
        this.color = color
    }
}

let cat = new Cat('大黄', 'red', '动物');

console.log(cat.species) // 动物
```

<div class="Alert Alert--porint">

弊端：  

`class` 支持不太友好，写法上与函数式有所不同

</div>







