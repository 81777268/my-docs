<!--
 * @Author: your name
 * @Date: 2021-11-26 10:39:49
 * @LastEditTime: 2021-11-26 11:21:38
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /my-docs/docs/74386313.md
-->

## 前言

作为当前世界上最强大的代码管理工具 `Git` 相信大家都很熟悉，但据我所知有很大一批人停留在 `clone`、`commit`、`pull`、`pujs`...的阶段，是不是对 `rebase` 心里没底只敢用 `merge`？

碰见版本回退就抓瞎？别问我怎么知道的，问就是：“我曾经就是这样啊～～”。

针对这些问题，今天我就将这几年对 `Git` 的认知和理解分享出来，尽可能的从本质去讲解 `Git`，帮助你一步一步去了解 `Git` 的底层原理，相信读完本篇文章你便可以换种姿态，更加风骚得使用 `Git` 各种指令。

## 基本概念

### Git 的优势

`Git` 是一个 **分布式代码管理** 工具，在讨论分布式之前避免不了提及一下什么是 **中央式代码管理仓库**

<div class="Alert Alert--point">

中央式：所有的代码保存在中央服务器，所以提交必须依赖网络，并且每次提交都会带入到中央仓库，如果是协同开发可能频繁触发代码合并，进而增加提交的成本和代价。最典型的就是 `svn`

</div>

<div class="Alert Alert--point">

分布式：可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库 `clone` 一份到本地，并会把提交历史一并拿过来。代表就是 `Git`

</div>

那 `Git` 相比于 `svn` 有什么优势呢？

打个比方："巴拉巴拉写了一大堆代码，突然发现写的有问题，我想回到一个小时之前"，对于这种情况 `Git` 的优势就很明显了，因为 `commit` 的成本比较小并且 **本地会保存所有的提交记录**，随时随刻可以进行回退。

在这并不是说 `svn` 的不能完成这种操作，只是 `Git` 的回退会显得更加的优雅。`Git` 相比于中央式工具还有很多优点，就不一一列举了，感兴趣的可自行了解。

### 文件状态

在 `Git` 中文件大概分为三种状态：**已修改（`modified`）**、**已暂存（`staged`）**、**已提交（`committed`）**

**修改**：`Git` 可以感知到工作目录中哪些文件被修改了，然后把修改的文件加入到 `modified` 区域

**暂存**：通过 `add` 命令将工作目录中修改的文件提交到暂存区，等候被 `commit`

**提交**：将暂存区文件 `commit` 至 `Git` 目录中永久保存

### commit 节点

<div class="Alert">

为了便于表述，本篇文章我会通过节点代称 `commit` 提交

</div>

在 `Git` 中每次提交都会生成一个节点，而每个节点都会有一个 **哈希值** 作为唯一标示，多次提交会形成一个线性节点链（不考虑 `merge` 的情况）

### HEAD

`HEAD` 是 `Git` 中非常重要的一个概念，你可以称它为 **指针** 或者 **引用**，它可以指向任意一个节点，并且指向的节点始终为当前工作目录，换句话说就是当前工作目录(也就是你所看到的代码)就是 `HEAD` 指向的节点。

### 远程仓库

虽然 `Git` 会把代码以及历史保存在本地，但最终还是要提交到服务器上的远程仓库。

通过 `clone` 命令可以把远程仓库的代码下载到本地，同时也会将**提交历史**、**分支**、 **`HEAD`** 等状态一并同步到本地，但这些状态并不会实时更新，需要手动从远程仓库去拉取，至于何时拉、怎么拉后面章节会讲到。

通过远程仓库为中介，你可以和你的同事进行协同开发，开发完新功能后可以申请提交至远程仓库，同时也可以从远程仓库拉取你同事的代码。

## 分支

### 什么是分支？

分支也是 `Git` 中相当重要的一个概念，当一个分支指向一个节点时，**当前节点的内容即是该分支的内容**，它的概念和 `HEAD` 非常接近同样也可以视为指针或引用，不同的是分支可以存在多个，而 `HEAD` 只有一个。通常会根据功能或版本建立不同的分支。

<div class="Alert Alert--point">

除此之外利用分支还可以做很多事情，比如现在有一个需求不确定要不要上线，但是得先做，此时可以单独创建一个分支开发该功能，等到啥时候需要上线直接合并到主分支即可。分支适用的场景很多就不一一列举了。

</div>

<div class="Alert">

当在某个节点创建一个分支后，并不会把该节点对应的代码复制一份出来，只是将 **新分支指向该节点**，因此可以很大程度减少空间上的开销。一定要记着不管是 `HEAD` 还是分支它们都只是引用而已，量级非常轻

</div>

## 命令详解

### 提交相关

前面我们提到过，想要对代码进行提交必须得先加入到暂存区，`Git` 中是通过命令 `add` 实现

添加某个文件到暂存区：

```js
git add path
```

添加所有文件到暂存区：

```js
git add .
```

同时 `Git` 也提供了撤销工作区和暂存区命令

撤销工作区改动：

```js
git checkout -- path
```

清空暂存区：

```js
git reset HEAD name | .
```

提交：

将改动文件加入到暂存区后就可以进行提交了，提交后会生成一个新的提交节点，具体命令如下：

```js
git commit -m "describe"
```

### 分支相关

创建分支

创建一个分支后该分支会与 `HEAD` 指向同一节点，说通俗点就是 `HEAD` 指向哪创建的新分支就指向哪，命令如下：

```js
git branch name
```

切换分支

当切换分支后，默认情况下 `HEAD` 会指向当前分支，即 `HEAD` 间接指向当前分支指向的节点

```js
git checkout name
```

同时也可以创建一个分支后立即切换，命令如下：

```js
git checkout -b name
```

删除分支

为了保证仓库分支的简洁，当某个分支完成了它的使命后应该被删除。比如前面所说的单独开一个分支完成某个功能，当这个功能被合并到主分支后应该将这个分支及时删除。

删除命令如下：

```js
git branch -d name
```

### 合并相关

关于合并的命令是最难掌握同时也是最重要的。我们常用的合并命令大概有三个 `merge`、`rebase`、`cherry-pick`

**merge**

`merge` 是最常用的合并命令，它可以将某个分支或者某个节点的代码合并至当前分支。具体命令如下：

```js
git merge branchName/hajs
```

**rebase**

`rebase` 也是一种合并指令，命令行如下：

```js
git rebase branchName/hajs
```

与 `merge` 不同的是 `rebase` 合并看起来不会产生新的节点(**实际上是会产生的，只是做了一次复制**)，而是将需要合并的节点直接累加

`rebase` 相比于 `merge` 提交历史更加线性、干净，使并行的开发流程看起来像串行，更符合我们的直觉。既然 `rebase` 这么好用是不是可以抛弃 `merge` 了？其实也不是了，下面我罗列一些 merge 和 rebase 的优缺点：

`merge` 优缺点：

**优点**：每个节点都是严格按照时间排列。当合并发生冲突时，只需要解决两个分支所指向的节点的冲突即可

**缺点**：合并两个分支时大概率会生成新的节点并分叉，久而久之提交历史会变成一团乱麻

`rebase` 优缺点：

**优点**：会使提交历史看起来更加线性、干净

**缺点**：虽然提交看起来像是线性的，但并不是真正的按时间排序，并且当合并发生冲突时，理论上来讲有几个节点 `rebase` 到目标分支就可能处理几次冲突

对于网络上一些只用 `rebase` 的观点，作者表示不太认同，如果不同分支的合并使用 `rebase` 可能需要重复解决冲突，这样就得不偿失了。

但如果是本地推到远程并对应的是同一条分支可以优先考虑 `rebase`。所以我的观点是 根据不同场景合理搭配使用 `merge` 和 `rebase`，如果觉得都行那优先使用 `rebase`

**cherry-pick**

`cherry-pick` 的合并不同于 `merge` 和 `rebase`，它可以选择某几个节点进行合并。

命令行：

```js
git cherry-pick hajs
```

### 回退相关

分离 `HEAD`

在默认情况下 `HEAD` 是指向分支的，但也可以将 `HEAD` 从分支上取下来直接指向某个节点，此过程就是分离 `HEAD`，具体命令如下：

```js
git checkout hajs
//也可以直接脱离分支指向当前节点
git checkout --detach
```

由于哈希值是一串很长很长的乱码，在实际操作中使用哈希值分离 `HEAD` 很麻烦，所以 `Git` 也提供了 `HEAD` 基于某一特殊位置(**分支/`HEAD`**)直接指向前一个或前 `N` 个节点的命令，也即相对引用，如下：

```js
//HEAD 分离并指向前一个节点
git checkout branchName/HEAD^
```

```js
//HEAD 分离并指向前 N 个节点
git checkout branchName～ N
```

将 `HEAD` 分离出来指向节点有什么用呢？

举个例子：如果开发过程发现之前的提交有问题，此时可以将 `HEAD` 指向对应的节点，修改完毕后再提交，此时你肯定不希望再生成一个新的节点，而你只需在提交时加上`--amend` 即可，具体命令如下：

```js
git commit --amend
```

**回退**

回退场景在平时开发中还是比较常见的，比如你巴拉巴拉写了一大堆代码然后提交，后面发现写的有问题，于是你想将代码回到前一个提交，这种场景可以通过 `reset` 解决，具体命令如下：

```js
//回退 N 个提交
git reset HEAD~N
```

`reset` 和相对引用很像，区别是 `reset` 会使分支和 `HEAD` 一并回退。

### 远程相关

当我们接触一个新项目时，第一件事情肯定是要把它的代码拿下来，在 `Git` 中可以通过 `clone` 从远程仓库复制一份代码到本地，具体命令如下：

```js
git clone remoteUrl
```

前面的章节我也有提到过，`clone` 不仅仅是复制代码，它还会把远程仓库的引用(**分支/`HEAD`**)一并取下保存在本地

**fetch**

说的通俗一点，`fetch` 命令就是一次下载操作，它会将远程新增加的节点以及引用(**分支/`HEAD`**)的状态下载到本地，具体命令如下：

```js
git fetch remote/branchName
```

**pull**

`pull` 命令可以从远程仓库的某个引用拉取代码，具体命令如下：

```js
git pull remote
```

其实 `pull` 的本质就是 `fetch + merge`，首先更新远程仓库所有状态到本地，随后再进行合并。**合并完成后本地分支会指向最新节点**

另外 `pull` 命令也可以通过 `rebase` 进行合并，具体命令如下：

```js
git pull --rebase 远程分支名
```

**pujs**

`pujs` 命令可以将本地提交推送至远程，具体命令如下：

```js
git pujs remote
```

如果直接 `pujs` 可能会失败，因为可能存在冲突，所以在 `pujs` 之前往往会先 `pull` 一下，如果存在冲突本地解决。`pujs` 成功后本地的远程分支引用会更新，与本地分支指向同一节点。

<div class="Alert">

综上所述

- 不管是 `HEAD` 还是分支，它们都只是引用而已，**引用** + **节点**是 `Git` 构成分布式的关键

- `merge` 相比于 `rebase` 有更明确的时间历史，而 `rebase` 会使提交更加线性应当优先使用

- 通过移动 `HEAD` 可以查看每个提交对应的代码

- `clone` 或 `fetch` 都会将远程仓库的所有提交、引用保存在本地一份

- `pull` 的本质其实就是 `fetch + merge`，也可以加入`--rebase` 通过 `rebase` 方式合并

</div>
