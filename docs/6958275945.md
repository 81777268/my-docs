<!--
 * @Author: your name
 * @Date: 2021-05-08 10:40:03
 * @LastEditTime: 2021-05-08 14:40:40
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /my-docs/docs/6958275945.md
-->

## 前言

<img src='./_media/1_gdoQ1_5OID90wf1eLTFvWw.png' width='80%' />

在前端 **工程化** 日趋复杂的今天，模块打包工具在我们的开发中起到了越来越重要的作用，其中 `webpack` 就是最热门的打包工具之一。　　

说到 `webpack` ，可能很多小伙伴会觉得既熟悉又陌生，熟悉是因为几乎在每一个项目中我们都会用上它，又因为 `webpack` 复杂的配置和五花八门的功能感到陌生。尤其当我们使用诸如 `umi.js` 之类的应用框架还帮我们把 `webpack` 配置再封装一层的时候，`webpack` 的本质似乎离我们更加遥远和深不可测了。

当面试官问你是否了解 `webpack` 的时候，或许你可以说出一串耳熟能详的 `loader` 和 `plugin` 的名字，甚至还能说出插件和一系列配置做按需加载和打包优化，那你是否了解他的 `运行机制` 及 `实现原理` 呢，那我们今天就一起探索 `webpack` 的能力边界，尝试了解 `webpack` 的一些实现流程和原理，拒做API工程师。

<img src='./_media/68747470733a2f2f7765627061636b2e6769746875622e696f2f6173736574732f776861742d69732d7765627061636b2e706e67.png' width='80%' />

## webpack的作用是什么？

从官网上的描述我们其实不难理解，`webpack` 的作用其实有以下几点：

- **模块打包**。可以将不同模块的文件 **打包整合** 在一起，并且保证它们之间的 **引用正确** ，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。　　

- **编译兼容**。在前端的 **上古时期**，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过 `webpack` 的 `Loader` 机制，不仅仅可以帮助我们对代码做 `polyfill` ，还可以编译转换诸如 `.less`, `.vue`, `.jsx` 这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。

- **能力扩展**。通过 `webpack` 的 `Plugin` 机制，我们在实现 **模块化打包** 和 **编译兼容** 的基础上，可以进一步实现诸如 **按需加载**，**代码压缩** 等一系列功能，帮助我们进一步提高 **自动化** 程度，工程效率以及打包输出的质量。

## 模块打包运行原理

首先我们应该简单了解一下 `webpack` 的整个打包流程：

1. 读取 `webpack` 的配置参数；

2. 启动 `webpack` ，创建 `Compiler` 对象并开始 **解析项目**；

3. 从 **入口文件**（`entry`）开始解析，并且找到其导入的依赖模块，**递归遍历** 分析，形成 **依赖关系树**；

4. 对 **不同文件类型** 的依赖模块文件使用 **对应** 的 `Loader` 进行编译，最终转为 `Javascript` 文件；

5. 整个过程中 `webpack` 会通过 **发布订阅模式** ，向外抛出一些 **hooks** ，而 `webpack` 的 **插件** 即可通过 **监听** 这些关键的 **事件节点**，执行插件任务进而达到干预输出结果的目的。

> 其中文件的解析与构建是一个比较复杂的过程，在 `webpack` 源码中主要依赖于 `compiler` 和 `compilation` 两个核心对象实现。

`compiler` 对象是一个 **全局单例**，他负责把控整个 `webpack` 打包的构建流程。

`compilation` 对象是每一次构建的 **上下文对象**，它包含了 **当次构建所需要的所有信息**，每次 **热更新** 和 **重新构建** ，`compiler` 都会重新生成一个新的 `compilation` 对象，负责此次更新的 **构建过程**。

每个模块间的依赖关系，则依赖于 **`AST` 语法树** 。每个模块文件在通过 `Loader` 解析完成之后，会通过 **`acorn` 库** 生成模块代码的 **`AST`语法树** ，通过 **语法树** 就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。

**最终 `Webpack` 打包出来的 `bundle` 文件是一个 `IIFE` 的执行函数**。

```js
// webpack 5 打包的bundle文件内容

(() => { // webpackBootstrap
    var __webpack_modules__ = ({
        'file-A-path': ((modules) => { // ... })
        'index-file-path': ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => { // ... })
    })
    
    // The module cache
    var __webpack_module_cache__ = {};
    
    // The require function
    function __webpack_require__(moduleId) {
        // Check if module is in cache
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
                return cachedModule.exports;
        }
        // Create a new module (and put it into the cache)
        var module = __webpack_module_cache__[moduleId] = {
                // no module.id needed
                // no module.loaded needed
                exports: {}
        };

        // Execute the module function
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__ "moduleId");

        // Return the exports of the module
        return module.exports;
    }
    
    // startup
    // Load entry module and return exports
    // This entry module can't be inlined because the eval devtool is used.
    var __webpack_exports__ = __webpack_require__("./src/index.js");
})
```

和 `webpack4` 相比，`webpack5` 打包出来的 `bundle` 做了相当的精简。

在上面的打包demo中，整个立即执行函数里边只有 **三个变量** 和 **一个函数方法** ，`__webpack_modules__` 存放了 **编译后** 的各个文件模块的 `JS` 内容，`__webpack_module_cache__ ` 用来做 **模块缓存**，`__webpack_require__` 是 `Webpack` 内部实现的一套 **依赖引入函数**。最后一句则是代码运行的起点，从 **入口文件** 开始，启动整个项目。

其中值得一提的是 `__webpack_require__` 模块引入函数，我们在模块化开发的时候，通常会使用 `ES Module` 或者 `CommonJS` 规范导出/引入依赖模块，`webpack` 打包编译的时候，会统一替换成自己的 `__webpack_require__` 来实现模块的引入和导出，从而实现 **模块缓存机制**，以及 **抹平不同模块** 规范之间的一些 **差异性**。

## sourceMap是什么？

提到 `sourceMap` ，很多小伙伴可能会立刻想到 `Webpack` 配置里边的 `devtool` 参数，以及对应的 `eval` ，`eval-cheap-source-map` 等等可选值以及它们的含义。除了知道不同参数之间的区别以及性能上的差异外，我们也可以一起了解一下 `sourceMap` 的实现方式。

`sourceMap` 是一项将 **编译**、**打包**、**压缩后的代码映射回源代码** 的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中 `debug` 问题会带来非常糟糕的体验，`sourceMap` 可以帮助我们快速定位到源代码的位置，提高我们的开发效率。

> `sourceMap` 其实并不是 `Webpack` 特有的功能，而是 `Webpack` 支持 `sourceMap` ，像 `JQuery` 也支持 `souceMap` 。

既然是一种源码的映射，那必然就需要有一份 **映射文件**，来标记混淆代码里 **对应的源码位置**，通常这份映射文件以 `.map` 结尾，里边的数据结构大概长这样：

```js
{
  "version" : 3,                          // Source Map版本
  "file": "out.js",                       // 输出文件（可选）
  "sourceRoot": "",                       // 源文件根目录（可选）
  "sources": ["foo.js", "bar.js"],        // 源文件列表
  "sourcesContent": [null, null],         // 源内容列表（可选，和源文件列表顺序一致）
  "names": ["src", "maps", "are", "fun"], // mappings使用的符号名称列表
  "mappings": "A,AAAB;;ABCDE;"            // 带有编码映射数据的字符串
}
```

有了这份映射文件，我们只需要在我们的压缩代码的最末端加上这句 **注释**，即可让 `sourceMap` 生效：

```js
//# sourceURL=/path/to/file.js.map
```

有了这段注释后，**浏览器** 就会通过 `sourceURL` 去获取这份映射文件，通过 **解释器** 解析后，实现源码和混淆代码之间的映射。因此 `sourceMap` 其实也是一项需要 **浏览器支持** 的技术。

如果我们仔细查看 `webpack` 打包出来的 `bundle` 文件，就可以发现在默认的 `development` 开发模式下，每个 `__webpack_modules__` 文件模块的代码最末端，都会加上 `//# sourceURL=webpack://file-path?` ，从而实现对 `sourceMap` 的支持。

## Loader的作用

从 `Webpack` 的打包原理我们其实可以知道，`Webpack` 最后打包出来的成果是一份 `Javascript` 代码，实际上在 `Webpack` 内部默认也只能够处理 `JS模块` 代码。

在打包过程中，会默认把 **所有遇到的文件** 都当作 `JavaScript` 代码进行解析，因此当项目存在 **非JS类型文件** 时，我们需要先对其进行 **必要的转换**，才能继续执行打包任务，这也是 `Loader` 机制存在的意义。

`Loader` 的配置使用我们应该已经非常的熟悉：

```js
// webpack.config.js
module.exports = {
  // ...other config
  module: {
    rules: [
      {
        test: /^your-regExp$/,
        use: [
          {
             loader: 'loader-name-A',
          }, 
          {
             loader: 'loader-name-B',
          }
        ]
      },
    ]
  }
}
```

通过配置可以看出，针对每个文件类型，`loader` 是支持以 **数组** 的形式配置多个的，因此当 `Webpack` 在转换该文件类型的时候，会 **按顺序链式调用** 每一个 `loader` ，前一个 `loader` 返回的内容会作为下一个 `loader` 的入参。

因此 `loader` 的开发需要遵循一些规范，比如 **返回值** 必须是 **标准的JS代码字符串**，以保证下一个 `loader` 能够正常工作，同时在开发上需要严格遵循 **单一职责**，只关心 `loader` 的输出以及对应的输出。

`loader` 函数中的 `this上下文` 由 `webpack` 提供，可以通过 `this` 对象提供的相关属性，获取当前 `loader` 需要的各种 **信息数据**，事实上，这个 `this` 指向了一个叫 `loaderContext` 的 `loader-runner` 特有对象。有兴趣的小伙伴可以自行阅读源码。

```js
module.exports = function(source) {
    const content = doSomeThing2JsString(source);
    
    // 如果 loader 配置了 options 对象，那么this.query将指向 options
    const options = this.query;
    
    // 可以用作解析其他模块路径的上下文
    console.log('this.context');
    
    /*
     * this.callback 参数：
     * error：Error | null，当 loader 出错时向外抛出一个 error
     * content：String | Buffer，经过 loader 编译后需要导出的内容
     * sourceMap：为方便调试生成的编译后内容的 source map
     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程
     */
    this.callback(null, content);
    // or return content;
}
```

## Plugin的作用

如果说 `Loader` 负责 **文件转换**，那么 `Plugin` 便是负责 **功能扩展**。`Loader` 和 `Plugin` 作为 `Webpack` 的两个重要组成部分，承担着两部分不同的职责。

上文已经说过，`webpack` 基于 **发布订阅模式**，在运行的生命周期中会广播出许多事件，插件通过 **监听这些事件**，就可以在特定的阶段 **执行自己的插件任务**，从而实现自己想要的功能。

既然基于 **发布订阅模式**，那么知道 `Webpack` 到底提供了哪些事件钩子供插件开发者使用是非常重要的，上文提到过 `compiler` 和 `compilation` 是 `Webpack`两个非常核心的对象，其中 `compiler` 暴露了和 `Webpack` 整个 **生命周期相关的钩子**（`compiler-hooks`），而 `compilation` 则暴露了 **与模块和依赖有关** 的 **粒度更小** 的事件钩子（`compilation-hooks`）。

`Webpack` 的事件机制基于自己实现的一套 `Tapable` 事件流方案：

```js
// Tapable的简单使用
const { SyncHook } = require("tapable");

class Car {
    constructor() {
        // 在this.hooks中定义所有的钩子事件
        this.hooks = {
            accelerate: new SyncHook(["newSpeed"]),
            brake: new SyncHook(),
            calculateRoutes: new AsyncParallelHook(["source", "target", "routesList"])
        };
    }

    /* ... */
}

const myCar = new Car();
// 通过调用tap方法即可增加一个消费者，订阅对应的钩子事件了
myCar.hooks.brake.tap("WarningLampPlugin", () => warningLamp.on());
```

`Plugin` 的开发和开发 `Loader` 一样，需要遵循一些开发上的规范和原则：

- 插件必须是一个 **函数** 或者是一个包含 `apply` 方法的 **对象** ，这样才能访问 `compiler` 实例；

- 传给每个插件的 `compiler` 和 `compilation` 对象都是 **同一个引用**，若在一个 **插件** 中修改了它们身上的属性，会 **影响后面** 的插件;

- **异步的事件** 需要在插件处理完任务时 **调用回调函数** 通知 `Webpack` 进入下一个流程，不然会卡住;

```js
class CopyrightWebpackPlugin {
    apply (compiler) {
        compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (compilation, callback) => {
            compilation.assets['Copyright.txt'] = {
                source: function () {
                    return '这是一个版权文件'
                },
                size: function () {
                    return 8
                }
            }
            callback()
        })
    }
}
module.exports = CopyrightWebpackPlugin
```

[更多的webpack-hooks](https://blog.csdn.net/maogugu0319/article/details/107230497/)

## 最后

本文也是结合一些优秀的文章和 `webpack` 本身的源码，大概地说了几个相对重要的概念和流程，其中的实现细节和设计思路还需要结合源码去阅读和慢慢理解。　　


### PS 
[webpack打包配置解析](https://github.com/edonet/blog/blob/master/article/webpack/webpack%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90.md)

[webpack官网](https://webpack.js.org/)